import { config, icon, parse, text, counter } from '@fortawesome/fontawesome-svg-core';
import { __extends, __spread, __assign } from 'tslib';
import { Input, Component, HostBinding, Inject, Injectable, Optional, forwardRef, NgModule } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Returns if is IconLookup or not.
 * @return IconLookup
 */
var /** @type {?} */ isIconLookup = function (i) {
    return (/** @type {?} */ (i)).prefix !== undefined && (/** @type {?} */ (i)).iconName !== undefined;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Normalizing icon spec.
 * @return IconLookup
 */
var /** @type {?} */ faNormalizeIconSpec = function (iconSpec) {
    var /** @type {?} */ defaultPrefix = 'fas';
    if (typeof iconSpec === 'undefined' || iconSpec === null) {
        return null;
    }
    if (isIconLookup(iconSpec)) {
        return iconSpec;
    }
    if (Array.isArray(iconSpec) && (/** @type {?} */ (iconSpec)).length === 2) {
        return { prefix: iconSpec[0], iconName: iconSpec[1] };
    }
    if (typeof iconSpec === 'string') {
        return { prefix: defaultPrefix, iconName: iconSpec };
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param T value
 */
var /** @type {?} */ objectWithKey = function (key, value) {
    return (Array.isArray(value) && value.length > 0) || (!Array.isArray(value) && value) ? (_a = {}, _a[key] = value, _a) : {};
    var _a;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Fontawesome class list.
 * Returns classes array by props.
 * @return string[]
 */
var /** @type {?} */ faClassList = function (props) {
    var /** @type {?} */ classes = (_a = {
            'fa-spin': props.spin,
            'fa-pulse': props.pulse,
            'fa-fw': props.fixedWidth,
            'fa-border': props.border,
            'fa-li': props.listItem,
            'fa-inverse': props.inverse,
            'fa-layers-counter': props.counter,
            'fa-flip-horizontal': props.flip === 'horizontal' || props.flip === 'both',
            'fa-flip-vertical': props.flip === 'vertical' || props.flip === 'both'
        },
        _a["fa-" + props.size] = props.size !== null,
        _a["fa-rotate-" + props.rotate] = props.rotate !== null,
        _a["fa-pull-" + props.pull] = props.pull !== null,
        _a);
    return Object.keys(classes)
        .map(function (key) { return (classes[key] ? key : null); })
        .filter(function (key) { return key; });
    var _a;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ faWarnIfIconHtmlMissing = function (iconObj, iconSpec) {
    if (iconSpec && !iconObj) {
        console.error("FontAwesome: Could not find icon with iconName=" + iconSpec.iconName + " and prefix=" + iconSpec.prefix);
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ faWarnIfIconSpecMissing = function (iconSpec) {
    if (!iconSpec) {
        console.error('FontAwesome: Could not find icon. ' +
            "It looks like you've provided a null or undefined icon object to this component.");
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ faNotFoundIconHtml = "<svg class=\"" + config.replacementClass + "\" viewBox=\"0 0 448 512\"></svg><!--icon not found-->";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Fontawesome icon.
 */
var FaIconComponent = (function () {
    function FaIconComponent(sanitizer) {
        this.sanitizer = sanitizer;
        this.classes = [];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    FaIconComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes) {
            this.updateIconSpec();
            this.updateParams();
            this.updateIcon();
            this.renderIcon();
        }
    };
    /**
     * Updating icon spec.
     * @return {?}
     */
    FaIconComponent.prototype.updateIconSpec = /**
     * Updating icon spec.
     * @return {?}
     */
    function () {
        this.iconSpec = faNormalizeIconSpec(this.iconProp);
    };
    /**
     * Updating params by component props.
     * @return {?}
     */
    FaIconComponent.prototype.updateParams = /**
     * Updating params by component props.
     * @return {?}
     */
    function () {
        var /** @type {?} */ classOpts = {
            flip: this.flip,
            spin: this.spin,
            pulse: this.pulse,
            border: this.border,
            inverse: this.inverse,
            listItem: this.listItem,
            size: this.size || null,
            pull: this.pull || null,
            rotate: this.rotate || null,
            fixedWidth: this.fixedWidth
        };
        var /** @type {?} */ classes = objectWithKey('classes', __spread(faClassList(classOpts), this.classes));
        var /** @type {?} */ mask = objectWithKey('mask', faNormalizeIconSpec(this.mask));
        var /** @type {?} */ parsedTransform = typeof this.transform === 'string' ? parse.transform(this.transform) : this.transform;
        var /** @type {?} */ transform = objectWithKey('transform', parsedTransform);
        this.params = __assign({ title: this.title }, transform, classes, mask, { styles: this.styles, symbol: this.symbol });
    };
    /**
     * Updating icon by params and icon spec.
     * @return {?}
     */
    FaIconComponent.prototype.updateIcon = /**
     * Updating icon by params and icon spec.
     * @return {?}
     */
    function () {
        this.icon = icon(this.iconSpec, this.params);
    };
    /**
     * Rendering icon.
     * @return {?}
     */
    FaIconComponent.prototype.renderIcon = /**
     * Rendering icon.
     * @return {?}
     */
    function () {
        faWarnIfIconSpecMissing(this.iconSpec);
        faWarnIfIconHtmlMissing(this.icon, this.iconSpec);
        this.renderedIconHTML = this.sanitizer.bypassSecurityTrustHtml(this.icon ? this.icon.html.join('\n') : faNotFoundIconHtml);
    };
    FaIconComponent.decorators = [
        { type: Component, args: [{
                    selector: 'fa-icon',
                    template: "",
                    host: {
                        class: 'ng-fa-icon',
                    }
                },] },
    ];
    /** @nocollapse */
    FaIconComponent.ctorParameters = function () { return [
        { type: DomSanitizer, },
    ]; };
    FaIconComponent.propDecorators = {
        "renderedIconHTML": [{ type: HostBinding, args: ['innerHTML',] },],
        "iconProp": [{ type: Input, args: ['icon',] },],
        "title": [{ type: Input },],
        "spin": [{ type: Input },],
        "pulse": [{ type: Input },],
        "mask": [{ type: Input },],
        "styles": [{ type: Input },],
        "flip": [{ type: Input },],
        "size": [{ type: Input },],
        "pull": [{ type: Input },],
        "border": [{ type: Input },],
        "inverse": [{ type: Input },],
        "symbol": [{ type: Input },],
        "listItem": [{ type: Input },],
        "rotate": [{ type: Input },],
        "fixedWidth": [{ type: Input },],
        "classes": [{ type: Input },],
        "transform": [{ type: Input },],
    };
    return FaIconComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Fontawesome layers.
 */
var FaLayersComponent = (function () {
    function FaLayersComponent() {
    }
    FaLayersComponent.decorators = [
        { type: Component, args: [{
                    selector: 'fa-layers',
                    template: "<ng-content select=\"fa-icon, fa-layers-text, fa-layers-counter\"></ng-content>",
                    host: {
                        class: 'fa-layers'
                    }
                },] },
    ];
    /** @nocollapse */
    FaLayersComponent.ctorParameters = function () { return []; };
    return FaLayersComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Warns if parent component not existing.
 */
var /** @type {?} */ faWarnIfParentNotExist = function (parent, parentName, childName) {
    if (!parent) {
        console.error("FontAwesome: " + childName + " should be used as child of " + parentName + " only.");
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 */
var FaLayersTextBaseComponent = (function () {
    function FaLayersTextBaseComponent(parent, sanitizer) {
        this.parent = parent;
        this.sanitizer = sanitizer;
        this.classes = [];
        faWarnIfParentNotExist(this.parent, 'FaLayersComponent', this.constructor.name);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    FaLayersTextBaseComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes) {
            this.updateParams();
            this.updateContent();
        }
    };
    /**
     * Updating content by params and content.
     * @return {?}
     */
    FaLayersTextBaseComponent.prototype.updateContent = /**
     * Updating content by params and content.
     * @return {?}
     */
    function () {
        this.renderedHTML = this.sanitizer.bypassSecurityTrustHtml(this.renderFontawesomeObject(this.content || '', this.params).html.join('\n'));
    };
    FaLayersTextBaseComponent.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    FaLayersTextBaseComponent.ctorParameters = function () { return [
        { type: FaLayersComponent, decorators: [{ type: Inject, args: [forwardRef(function () { return FaLayersComponent; }),] }, { type: Optional },] },
        { type: DomSanitizer, },
    ]; };
    FaLayersTextBaseComponent.propDecorators = {
        "renderedHTML": [{ type: HostBinding, args: ['innerHTML',] },],
        "content": [{ type: Input },],
        "title": [{ type: Input },],
        "styles": [{ type: Input },],
        "classes": [{ type: Input },],
    };
    return FaLayersTextBaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Fontawesome layers text.
 */
var FaLayersTextComponent = (function (_super) {
    __extends(FaLayersTextComponent, _super);
    function FaLayersTextComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Updating params by component props.
     */
    /**
     * Updating params by component props.
     * @return {?}
     */
    FaLayersTextComponent.prototype.updateParams = /**
     * Updating params by component props.
     * @return {?}
     */
    function () {
        var /** @type {?} */ classOpts = {
            flip: this.flip,
            spin: this.spin,
            pulse: this.pulse,
            border: this.border,
            inverse: this.inverse,
            listItem: this.listItem,
            size: this.size || null,
            pull: this.pull || null,
            rotate: this.rotate || null,
            fixedWidth: this.fixedWidth
        };
        var /** @type {?} */ classes = objectWithKey('classes', __spread(faClassList(classOpts), this.classes));
        var /** @type {?} */ parsedTransform = typeof this.transform === 'string' ? parse.transform(this.transform) : this.transform;
        var /** @type {?} */ transform = objectWithKey('transform', parsedTransform);
        this.params = __assign({}, transform, classes, { title: this.title, styles: this.styles });
    };
    /**
     * @param {?} content
     * @param {?=} params
     * @return {?}
     */
    FaLayersTextComponent.prototype.renderFontawesomeObject = /**
     * @param {?} content
     * @param {?=} params
     * @return {?}
     */
    function (content, params) {
        return text(content, params);
    };
    FaLayersTextComponent.decorators = [
        { type: Component, args: [{
                    selector: 'fa-layers-text',
                    template: '',
                    host: {
                        class: 'ng-fa-layers-text'
                    }
                },] },
    ];
    /** @nocollapse */
    FaLayersTextComponent.ctorParameters = function () { return []; };
    FaLayersTextComponent.propDecorators = {
        "spin": [{ type: Input },],
        "pulse": [{ type: Input },],
        "flip": [{ type: Input },],
        "size": [{ type: Input },],
        "pull": [{ type: Input },],
        "border": [{ type: Input },],
        "inverse": [{ type: Input },],
        "listItem": [{ type: Input },],
        "rotate": [{ type: Input },],
        "fixedWidth": [{ type: Input },],
        "transform": [{ type: Input },],
    };
    return FaLayersTextComponent;
}(FaLayersTextBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Fontawesome layers counter.
 */
var FaLayersCounterComponent = (function (_super) {
    __extends(FaLayersCounterComponent, _super);
    function FaLayersCounterComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Updating params by component props.
     */
    /**
     * Updating params by component props.
     * @return {?}
     */
    FaLayersCounterComponent.prototype.updateParams = /**
     * Updating params by component props.
     * @return {?}
     */
    function () {
        this.params = {
            title: this.title,
            classes: this.classes,
            styles: this.styles,
        };
    };
    /**
     * @param {?} content
     * @param {?=} params
     * @return {?}
     */
    FaLayersCounterComponent.prototype.renderFontawesomeObject = /**
     * @param {?} content
     * @param {?=} params
     * @return {?}
     */
    function (content, params) {
        return counter(content, params);
    };
    FaLayersCounterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'fa-layers-counter',
                    template: '',
                    host: {
                        class: 'ng-fa-layers-counter'
                    }
                },] },
    ];
    /** @nocollapse */
    FaLayersCounterComponent.ctorParameters = function () { return []; };
    return FaLayersCounterComponent;
}(FaLayersTextBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FontAwesomeModule = (function () {
    function FontAwesomeModule() {
    }
    FontAwesomeModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [
                        FaIconComponent,
                        FaLayersComponent,
                        FaLayersTextComponent,
                        FaLayersCounterComponent
                    ],
                    exports: [
                        FaIconComponent,
                        FaLayersComponent,
                        FaLayersTextComponent,
                        FaLayersCounterComponent
                    ],
                },] },
    ];
    /** @nocollapse */
    FontAwesomeModule.ctorParameters = function () { return []; };
    return FontAwesomeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { FaIconComponent, FaLayersComponent, FaLayersTextComponent, FaLayersCounterComponent, FontAwesomeModule, FaLayersTextBaseComponent as Éµa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1mb250YXdlc29tZS5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQGZvcnRhd2Vzb21lL2FuZ3VsYXItZm9udGF3ZXNvbWUvc2hhcmVkL3V0aWxzL2lzLWljb24tbG9va3VwLnV0aWwudHMiLCJuZzovL0Bmb3J0YXdlc29tZS9hbmd1bGFyLWZvbnRhd2Vzb21lL3NoYXJlZC91dGlscy9ub3JtYWxpemUtaWNvbi1zcGVjLnV0aWwudHMiLCJuZzovL0Bmb3J0YXdlc29tZS9hbmd1bGFyLWZvbnRhd2Vzb21lL3NoYXJlZC91dGlscy9vYmplY3Qtd2l0aC1rZXlzLnV0aWwudHMiLCJuZzovL0Bmb3J0YXdlc29tZS9hbmd1bGFyLWZvbnRhd2Vzb21lL3NoYXJlZC91dGlscy9jbGFzc2xpc3QudXRpbC50cyIsIm5nOi8vQGZvcnRhd2Vzb21lL2FuZ3VsYXItZm9udGF3ZXNvbWUvc2hhcmVkL2Vycm9ycy93YXJuLWlmLWljb24taHRtbC1taXNzaW5nLnRzIiwibmc6Ly9AZm9ydGF3ZXNvbWUvYW5ndWxhci1mb250YXdlc29tZS9zaGFyZWQvZXJyb3JzL3dhcm4taWYtaWNvbi1zcGVjLW1pc3NpbmcudHMiLCJuZzovL0Bmb3J0YXdlc29tZS9hbmd1bGFyLWZvbnRhd2Vzb21lL3NoYXJlZC9lcnJvcnMvbm90LWZvdW5kLWljb24taHRtbC50cyIsIm5nOi8vQGZvcnRhd2Vzb21lL2FuZ3VsYXItZm9udGF3ZXNvbWUvaWNvbi9pY29uLmNvbXBvbmVudC50cyIsIm5nOi8vQGZvcnRhd2Vzb21lL2FuZ3VsYXItZm9udGF3ZXNvbWUvbGF5ZXJzL2xheWVycy5jb21wb25lbnQudHMiLCJuZzovL0Bmb3J0YXdlc29tZS9hbmd1bGFyLWZvbnRhd2Vzb21lL3NoYXJlZC9lcnJvcnMvd2Fybi1pZi1wYXJlbnQtbm90LWV4aXN0LnRzIiwibmc6Ly9AZm9ydGF3ZXNvbWUvYW5ndWxhci1mb250YXdlc29tZS9sYXllcnMvbGF5ZXJzLXRleHQtYmFzZS5jb21wb25lbnQudHMiLCJuZzovL0Bmb3J0YXdlc29tZS9hbmd1bGFyLWZvbnRhd2Vzb21lL2xheWVycy9sYXllcnMtdGV4dC5jb21wb25lbnQudHMiLCJuZzovL0Bmb3J0YXdlc29tZS9hbmd1bGFyLWZvbnRhd2Vzb21lL2xheWVycy9sYXllcnMtY291bnRlci5jb21wb25lbnQudHMiLCJuZzovL0Bmb3J0YXdlc29tZS9hbmd1bGFyLWZvbnRhd2Vzb21lL2ZvbnRhd2Vzb21lLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0ljb25Mb29rdXAsIEljb25Qcm9wfSBmcm9tICdAZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtc3ZnLWNvcmUnO1xuXG4vKipcbiAqIFJldHVybnMgaWYgaXMgSWNvbkxvb2t1cCBvciBub3QuXG4gKiBAcmV0dXJucyBJY29uTG9va3VwXG4gKi9cbmV4cG9ydCBjb25zdCBpc0ljb25Mb29rdXAgPSAoaTogSWNvblByb3ApOiBpIGlzIEljb25Mb29rdXAgPT4ge1xuICByZXR1cm4gKDxJY29uTG9va3VwPmkpLnByZWZpeCAhPT0gdW5kZWZpbmVkICYmICg8SWNvbkxvb2t1cD5pKS5pY29uTmFtZSAhPT0gdW5kZWZpbmVkO1xufTtcbiIsImltcG9ydCB7IEljb25Mb29rdXAsIEljb25Qcm9wIH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZvbnRhd2Vzb21lLXN2Zy1jb3JlJztcblxuaW1wb3J0IHsgaXNJY29uTG9va3VwIH0gZnJvbSAnLi9pcy1pY29uLWxvb2t1cC51dGlsJztcblxuLyoqXG4gKiBOb3JtYWxpemluZyBpY29uIHNwZWMuXG4gKiBAcmV0dXJucyBJY29uTG9va3VwXG4gKi9cbmV4cG9ydCBjb25zdCBmYU5vcm1hbGl6ZUljb25TcGVjID0gKGljb25TcGVjOiBJY29uUHJvcCk6IEljb25Mb29rdXAgPT4ge1xuICBjb25zdCBkZWZhdWx0UHJlZml4ID0gJ2Zhcyc7XG5cbiAgaWYgKHR5cGVvZiBpY29uU3BlYyA9PT0gJ3VuZGVmaW5lZCcgfHwgaWNvblNwZWMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0ljb25Mb29rdXAoaWNvblNwZWMpKSB7XG4gICAgcmV0dXJuIGljb25TcGVjO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaWNvblNwZWMpICYmICg8QXJyYXk8c3RyaW5nPj5pY29uU3BlYykubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIHsgcHJlZml4OiBpY29uU3BlY1swXSwgaWNvbk5hbWU6IGljb25TcGVjWzFdIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGljb25TcGVjID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IHByZWZpeDogZGVmYXVsdFByZWZpeCwgaWNvbk5hbWU6IGljb25TcGVjIH07XG4gIH1cbn07XG4iLCIvKipcbiAqIEBwYXJhbSBUIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBvYmplY3RXaXRoS2V5ID0gPFQ+KGtleTogc3RyaW5nLCB2YWx1ZTogVCk6IHtbaWQ6IHN0cmluZ106IFR9ID0+IHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB8fCAoIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlKSA/IHsgW2tleV06IHZhbHVlIH0gOiB7fTtcbn07XG4iLCJpbXBvcnQgeyBGYVByb3BzIH0gZnJvbSAnLi4vbW9kZWxzL3Byb3BzLm1vZGVsJztcblxuLyoqXG4gKiBGb250YXdlc29tZSBjbGFzcyBsaXN0LlxuICogUmV0dXJucyBjbGFzc2VzIGFycmF5IGJ5IHByb3BzLlxuICogQHJldHVybnMgc3RyaW5nW11cbiAqL1xuZXhwb3J0IGNvbnN0IGZhQ2xhc3NMaXN0ID0gKHByb3BzOiBGYVByb3BzKTogc3RyaW5nW10gPT4ge1xuICBjb25zdCBjbGFzc2VzID0ge1xuICAgICdmYS1zcGluJzogcHJvcHMuc3BpbixcbiAgICAnZmEtcHVsc2UnOiBwcm9wcy5wdWxzZSxcbiAgICAnZmEtZncnOiBwcm9wcy5maXhlZFdpZHRoLFxuICAgICdmYS1ib3JkZXInOiBwcm9wcy5ib3JkZXIsXG4gICAgJ2ZhLWxpJzogcHJvcHMubGlzdEl0ZW0sXG4gICAgJ2ZhLWludmVyc2UnOiBwcm9wcy5pbnZlcnNlLFxuICAgICdmYS1sYXllcnMtY291bnRlcic6IHByb3BzLmNvdW50ZXIsXG4gICAgJ2ZhLWZsaXAtaG9yaXpvbnRhbCc6IHByb3BzLmZsaXAgPT09ICdob3Jpem9udGFsJyB8fCBwcm9wcy5mbGlwID09PSAnYm90aCcsXG4gICAgJ2ZhLWZsaXAtdmVydGljYWwnOiBwcm9wcy5mbGlwID09PSAndmVydGljYWwnIHx8IHByb3BzLmZsaXAgPT09ICdib3RoJyxcbiAgICBbYGZhLSR7cHJvcHMuc2l6ZX1gXTogcHJvcHMuc2l6ZSAhPT0gbnVsbCxcbiAgICBbYGZhLXJvdGF0ZS0ke3Byb3BzLnJvdGF0ZX1gXTogcHJvcHMucm90YXRlICE9PSBudWxsLFxuICAgIFtgZmEtcHVsbC0ke3Byb3BzLnB1bGx9YF06IHByb3BzLnB1bGwgIT09IG51bGxcbiAgfTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMoY2xhc3NlcylcbiAgICAubWFwKGtleSA9PiAoY2xhc3Nlc1trZXldID8ga2V5IDogbnVsbCkpXG4gICAgLmZpbHRlcihrZXkgPT4ga2V5KTtcbn07XG4iLCJpbXBvcnQgeyBJY29uLCBJY29uTG9va3VwIH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZvbnRhd2Vzb21lLXN2Zy1jb3JlJztcblxuZXhwb3J0IGNvbnN0IGZhV2FybklmSWNvbkh0bWxNaXNzaW5nID0gKGljb25PYmo6IEljb24sIGljb25TcGVjOiBJY29uTG9va3VwKSA9PiB7XG4gIGlmIChpY29uU3BlYyAmJiAhaWNvbk9iaikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEZvbnRBd2Vzb21lOiBDb3VsZCBub3QgZmluZCBpY29uIHdpdGggaWNvbk5hbWU9JHtpY29uU3BlYy5pY29uTmFtZX0gYW5kIHByZWZpeD0ke2ljb25TcGVjLnByZWZpeH1gKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IEljb25Mb29rdXAgfSBmcm9tICdAZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtc3ZnLWNvcmUnO1xuXG5leHBvcnQgY29uc3QgZmFXYXJuSWZJY29uU3BlY01pc3NpbmcgPSAoaWNvblNwZWM6IEljb25Mb29rdXApID0+IHtcbiAgaWYgKCFpY29uU3BlYykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZvbnRBd2Vzb21lOiBDb3VsZCBub3QgZmluZCBpY29uLiAnICtcbiAgICAgIGBJdCBsb29rcyBsaWtlIHlvdSd2ZSBwcm92aWRlZCBhIG51bGwgb3IgdW5kZWZpbmVkIGljb24gb2JqZWN0IHRvIHRoaXMgY29tcG9uZW50LmApO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZvbnRhd2Vzb21lLXN2Zy1jb3JlJztcblxuZXhwb3J0IGNvbnN0IGZhTm90Rm91bmRJY29uSHRtbCA9IGA8c3ZnIGNsYXNzPVwiJHtjb25maWcucmVwbGFjZW1lbnRDbGFzc31cIiB2aWV3Qm94PVwiMCAwIDQ0OCA1MTJcIj48L3N2Zz48IS0taWNvbiBub3QgZm91bmQtLT5gO1xuIiwiaW1wb3J0IHtcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgQ29tcG9uZW50LFxuICBIb3N0QmluZGluZyxcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIGljb24sXG4gIEljb24sXG4gIHBhcnNlLFxuICBTdHlsZXMsXG4gIFB1bGxQcm9wLFxuICBJY29uUHJvcCxcbiAgU2l6ZVByb3AsXG4gIEZsaXBQcm9wLFxuICBGYVN5bWJvbCxcbiAgVHJhbnNmb3JtLFxuICBJY29uUGFyYW1zLFxuICBJY29uTG9va3VwLFxuICBSb3RhdGVQcm9wXG59IGZyb20gJ0Bmb3J0YXdlc29tZS9mb250YXdlc29tZS1zdmctY29yZSc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIsIFNhZmVIdG1sIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5cbmltcG9ydCB7IGZhTm9ybWFsaXplSWNvblNwZWMgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMvbm9ybWFsaXplLWljb24tc3BlYy51dGlsJztcbmltcG9ydCB7IEZhUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvbW9kZWxzL3Byb3BzLm1vZGVsJztcbmltcG9ydCB7IG9iamVjdFdpdGhLZXkgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMvb2JqZWN0LXdpdGgta2V5cy51dGlsJztcbmltcG9ydCB7IGZhQ2xhc3NMaXN0IH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzL2NsYXNzbGlzdC51dGlsJztcbmltcG9ydCB7IGZhV2FybklmSWNvbkh0bWxNaXNzaW5nIH0gZnJvbSAnLi4vc2hhcmVkL2Vycm9ycy93YXJuLWlmLWljb24taHRtbC1taXNzaW5nJztcbmltcG9ydCB7IGZhV2FybklmSWNvblNwZWNNaXNzaW5nIH0gZnJvbSAnLi4vc2hhcmVkL2Vycm9ycy93YXJuLWlmLWljb24tc3BlYy1taXNzaW5nJztcbmltcG9ydCB7IGZhTm90Rm91bmRJY29uSHRtbCB9IGZyb20gJy4uL3NoYXJlZC9lcnJvcnMvbm90LWZvdW5kLWljb24taHRtbCc7XG5cbi8qKlxuICogRm9udGF3ZXNvbWUgaWNvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZmEtaWNvbicsXG4gIHRlbXBsYXRlOiBgYCxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnbmctZmEtaWNvbicsXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgRmFJY29uQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgcHVibGljIGljb246IEljb247XG5cbiAgQEhvc3RCaW5kaW5nKCdpbm5lckhUTUwnKVxuICBwdWJsaWMgcmVuZGVyZWRJY29uSFRNTDogU2FmZUh0bWw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcikge31cblxuICBwcml2YXRlIHBhcmFtczogSWNvblBhcmFtcztcbiAgcHJpdmF0ZSBpY29uU3BlYzogSWNvbkxvb2t1cDtcblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5wdXQtcmVuYW1lXG4gIEBJbnB1dCgnaWNvbicpIHByaXZhdGUgaWNvblByb3A6IEljb25Qcm9wO1xuICBASW5wdXQoKSBwcml2YXRlIHRpdGxlPzogc3RyaW5nO1xuICBASW5wdXQoKSBwcml2YXRlIHNwaW4/OiBib29sZWFuO1xuICBASW5wdXQoKSBwcml2YXRlIHB1bHNlPzogYm9vbGVhbjtcbiAgQElucHV0KCkgcHJpdmF0ZSBtYXNrPzogSWNvblByb3A7XG4gIEBJbnB1dCgpIHByaXZhdGUgc3R5bGVzPzogU3R5bGVzO1xuICBASW5wdXQoKSBwcml2YXRlIGZsaXA/OiBGbGlwUHJvcDtcbiAgQElucHV0KCkgcHJpdmF0ZSBzaXplPzogU2l6ZVByb3A7XG4gIEBJbnB1dCgpIHByaXZhdGUgcHVsbD86IFB1bGxQcm9wO1xuICBASW5wdXQoKSBwcml2YXRlIGJvcmRlcj86IGJvb2xlYW47XG4gIEBJbnB1dCgpIHByaXZhdGUgaW52ZXJzZT86IGJvb2xlYW47XG4gIEBJbnB1dCgpIHByaXZhdGUgc3ltYm9sPzogRmFTeW1ib2w7XG4gIEBJbnB1dCgpIHByaXZhdGUgbGlzdEl0ZW0/OiBib29sZWFuO1xuICBASW5wdXQoKSBwcml2YXRlIHJvdGF0ZT86IFJvdGF0ZVByb3A7XG4gIEBJbnB1dCgpIHByaXZhdGUgZml4ZWRXaWR0aD86IGJvb2xlYW47XG4gIEBJbnB1dCgpIHByaXZhdGUgY2xhc3Nlcz86IHN0cmluZ1tdID0gW107XG4gIEBJbnB1dCgpIHByaXZhdGUgdHJhbnNmb3JtPzogc3RyaW5nIHwgVHJhbnNmb3JtO1xuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcykge1xuICAgICAgdGhpcy51cGRhdGVJY29uU3BlYygpO1xuICAgICAgdGhpcy51cGRhdGVQYXJhbXMoKTtcbiAgICAgIHRoaXMudXBkYXRlSWNvbigpO1xuICAgICAgdGhpcy5yZW5kZXJJY29uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0aW5nIGljb24gc3BlYy5cbiAgICovXG4gIHByaXZhdGUgdXBkYXRlSWNvblNwZWMoKSB7XG4gICAgdGhpcy5pY29uU3BlYyA9IGZhTm9ybWFsaXplSWNvblNwZWModGhpcy5pY29uUHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRpbmcgcGFyYW1zIGJ5IGNvbXBvbmVudCBwcm9wcy5cbiAgICovXG4gIHByaXZhdGUgdXBkYXRlUGFyYW1zKCkge1xuICAgIGNvbnN0IGNsYXNzT3B0czogRmFQcm9wcyA9IHtcbiAgICAgIGZsaXA6IHRoaXMuZmxpcCxcbiAgICAgIHNwaW46IHRoaXMuc3BpbixcbiAgICAgIHB1bHNlOiB0aGlzLnB1bHNlLFxuICAgICAgYm9yZGVyOiB0aGlzLmJvcmRlcixcbiAgICAgIGludmVyc2U6IHRoaXMuaW52ZXJzZSxcbiAgICAgIGxpc3RJdGVtOiB0aGlzLmxpc3RJdGVtLFxuICAgICAgc2l6ZTogdGhpcy5zaXplIHx8IG51bGwsXG4gICAgICBwdWxsOiB0aGlzLnB1bGwgfHwgbnVsbCxcbiAgICAgIHJvdGF0ZTogdGhpcy5yb3RhdGUgfHwgbnVsbCxcbiAgICAgIGZpeGVkV2lkdGg6IHRoaXMuZml4ZWRXaWR0aFxuICAgIH07XG5cbiAgICBjb25zdCBjbGFzc2VzID0gb2JqZWN0V2l0aEtleSgnY2xhc3NlcycsIFsuLi5mYUNsYXNzTGlzdChjbGFzc09wdHMpLCAuLi50aGlzLmNsYXNzZXNdKTtcbiAgICBjb25zdCBtYXNrID0gb2JqZWN0V2l0aEtleSgnbWFzaycsIGZhTm9ybWFsaXplSWNvblNwZWModGhpcy5tYXNrKSk7XG4gICAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gdHlwZW9mIHRoaXMudHJhbnNmb3JtID09PSAnc3RyaW5nJyA/IHBhcnNlLnRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSkgOiB0aGlzLnRyYW5zZm9ybTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBvYmplY3RXaXRoS2V5KCd0cmFuc2Zvcm0nLCBwYXJzZWRUcmFuc2Zvcm0pO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB7XG4gICAgICB0aXRsZTogdGhpcy50aXRsZSxcbiAgICAgIC4uLnRyYW5zZm9ybSxcbiAgICAgIC4uLmNsYXNzZXMsXG4gICAgICAuLi5tYXNrLFxuICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlcyxcbiAgICAgIHN5bWJvbDogdGhpcy5zeW1ib2xcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0aW5nIGljb24gYnkgcGFyYW1zIGFuZCBpY29uIHNwZWMuXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUljb24oKSB7XG4gICAgdGhpcy5pY29uID0gaWNvbih0aGlzLmljb25TcGVjLCB0aGlzLnBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyaW5nIGljb24uXG4gICAqL1xuICBwcml2YXRlIHJlbmRlckljb24oKSB7XG4gICAgZmFXYXJuSWZJY29uU3BlY01pc3NpbmcodGhpcy5pY29uU3BlYyk7XG4gICAgZmFXYXJuSWZJY29uSHRtbE1pc3NpbmcodGhpcy5pY29uLCB0aGlzLmljb25TcGVjKTtcblxuICAgIHRoaXMucmVuZGVyZWRJY29uSFRNTCA9IHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RIdG1sKFxuICAgICAgdGhpcy5pY29uID8gdGhpcy5pY29uLmh0bWwuam9pbignXFxuJykgOiBmYU5vdEZvdW5kSWNvbkh0bWxcbiAgICApO1xuICB9XG59XG5cbiIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEZvbnRhd2Vzb21lIGxheWVycy5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZmEtbGF5ZXJzJyxcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudCBzZWxlY3Q9XCJmYS1pY29uLCBmYS1sYXllcnMtdGV4dCwgZmEtbGF5ZXJzLWNvdW50ZXJcIj48L25nLWNvbnRlbnQ+YCxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnZmEtbGF5ZXJzJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIEZhTGF5ZXJzQ29tcG9uZW50IHtcbn1cblxuIiwiLyoqXG4gKiBXYXJucyBpZiBwYXJlbnQgY29tcG9uZW50IG5vdCBleGlzdGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGZhV2FybklmUGFyZW50Tm90RXhpc3QgPSAocGFyZW50OiBhbnksIHBhcmVudE5hbWU6IHN0cmluZywgY2hpbGROYW1lOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFwYXJlbnQpIHtcbiAgICBjb25zb2xlLmVycm9yKGBGb250QXdlc29tZTogJHtjaGlsZE5hbWV9IHNob3VsZCBiZSB1c2VkIGFzIGNoaWxkIG9mICR7cGFyZW50TmFtZX0gb25seS5gKTtcbiAgfVxufTtcbiIsImltcG9ydCB7XG4gIElucHV0LFxuICBJbmplY3QsXG4gIEluamVjdGFibGUsXG4gIE9wdGlvbmFsLFxuICBPbkNoYW5nZXMsXG4gIGZvcndhcmRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgU3R5bGVzLFxuICBGb250YXdlc29tZU9iamVjdCxcbiAgVGV4dFBhcmFtc1xufSBmcm9tICdAZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtc3ZnLWNvcmUnO1xuaW1wb3J0IHsgRG9tU2FuaXRpemVyLCBTYWZlSHRtbCB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuXG5pbXBvcnQgeyBGYUxheWVyc0NvbXBvbmVudCB9IGZyb20gJy4vbGF5ZXJzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBmYVdhcm5JZlBhcmVudE5vdEV4aXN0IH0gZnJvbSAnLi4vc2hhcmVkL2Vycm9ycy93YXJuLWlmLXBhcmVudC1ub3QtZXhpc3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRmFMYXllcnNUZXh0QmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cbiAgQEhvc3RCaW5kaW5nKCdpbm5lckhUTUwnKVxuICBwdWJsaWMgcmVuZGVyZWRIVE1MOiBTYWZlSHRtbDtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRmFMYXllcnNDb21wb25lbnQpKSBAT3B0aW9uYWwoKSBwcml2YXRlIHBhcmVudDogRmFMYXllcnNDb21wb25lbnQsXG4gICAgcHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcikge1xuXG4gICAgZmFXYXJuSWZQYXJlbnROb3RFeGlzdCh0aGlzLnBhcmVudCwgJ0ZhTGF5ZXJzQ29tcG9uZW50JywgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBwYXJhbXM6IFRleHRQYXJhbXM7XG5cbiAgQElucHV0KCkgcHJvdGVjdGVkIGNvbnRlbnQ6IHN0cmluZztcbiAgQElucHV0KCkgcHJvdGVjdGVkIHRpdGxlPzogc3RyaW5nO1xuICBASW5wdXQoKSBwcm90ZWN0ZWQgc3R5bGVzPzogU3R5bGVzO1xuICBASW5wdXQoKSBwcm90ZWN0ZWQgY2xhc3Nlcz86IHN0cmluZ1tdID0gW107XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBhcmFtcygpO1xuICAgICAgdGhpcy51cGRhdGVDb250ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0aW5nIHBhcmFtcyBieSBjb21wb25lbnQgcHJvcHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgdXBkYXRlUGFyYW1zKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgRm9udGF3ZXNvbWVPYmplY3QgdXNpbmcgdGhlIGNvbnRlbnQgYW5kIHBhcmFtcy5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZW5kZXJGb250YXdlc29tZU9iamVjdChjb250ZW50OiBzdHJpbmcgfCBudW1iZXIsIHBhcmFtcz86IFRleHRQYXJhbXMpOiBGb250YXdlc29tZU9iamVjdDtcblxuICAvKipcbiAgICogVXBkYXRpbmcgY29udGVudCBieSBwYXJhbXMgYW5kIGNvbnRlbnQuXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUNvbnRlbnQoKSB7XG4gICAgdGhpcy5yZW5kZXJlZEhUTUwgPSB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0SHRtbChcbiAgICAgIHRoaXMucmVuZGVyRm9udGF3ZXNvbWVPYmplY3QodGhpcy5jb250ZW50IHx8ICcnLCB0aGlzLnBhcmFtcykuaHRtbC5qb2luKCdcXG4nKVxuICAgICk7XG4gIH1cbn1cblxuIiwiaW1wb3J0IHtcbiAgSW5wdXQsXG4gIENvbXBvbmVudCxcbiAgSG9zdEJpbmRpbmdcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICB0ZXh0LFxuICBwYXJzZSxcbiAgVGV4dCxcbiAgVGV4dFBhcmFtcyxcbiAgU2l6ZVByb3AsXG4gIEZsaXBQcm9wLFxuICBQdWxsUHJvcCxcbiAgVHJhbnNmb3JtLFxuICBSb3RhdGVQcm9wXG59IGZyb20gJ0Bmb3J0YXdlc29tZS9mb250YXdlc29tZS1zdmctY29yZSc7XG5pbXBvcnQgeyBGYUxheWVyc1RleHRCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi9sYXllcnMtdGV4dC1iYXNlLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IEZhUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvbW9kZWxzL3Byb3BzLm1vZGVsJztcbmltcG9ydCB7IG9iamVjdFdpdGhLZXkgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMvb2JqZWN0LXdpdGgta2V5cy51dGlsJztcbmltcG9ydCB7IGZhQ2xhc3NMaXN0IH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzL2NsYXNzbGlzdC51dGlsJztcblxuLyoqXG4gKiBGb250YXdlc29tZSBsYXllcnMgdGV4dC5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZmEtbGF5ZXJzLXRleHQnLFxuICB0ZW1wbGF0ZTogJycsXG4gIGhvc3Q6IHtcbiAgICBjbGFzczogJ25nLWZhLWxheWVycy10ZXh0J1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIEZhTGF5ZXJzVGV4dENvbXBvbmVudCBleHRlbmRzIEZhTGF5ZXJzVGV4dEJhc2VDb21wb25lbnQge1xuXG4gIEBJbnB1dCgpIHByaXZhdGUgc3Bpbj86IGJvb2xlYW47XG4gIEBJbnB1dCgpIHByaXZhdGUgcHVsc2U/OiBib29sZWFuO1xuICBASW5wdXQoKSBwcml2YXRlIGZsaXA/OiBGbGlwUHJvcDtcbiAgQElucHV0KCkgcHJpdmF0ZSBzaXplPzogU2l6ZVByb3A7XG4gIEBJbnB1dCgpIHByaXZhdGUgcHVsbD86IFB1bGxQcm9wO1xuICBASW5wdXQoKSBwcml2YXRlIGJvcmRlcj86IGJvb2xlYW47XG4gIEBJbnB1dCgpIHByaXZhdGUgaW52ZXJzZT86IGJvb2xlYW47XG4gIEBJbnB1dCgpIHByaXZhdGUgbGlzdEl0ZW0/OiBib29sZWFuO1xuICBASW5wdXQoKSBwcml2YXRlIHJvdGF0ZT86IFJvdGF0ZVByb3A7XG4gIEBJbnB1dCgpIHByaXZhdGUgZml4ZWRXaWR0aD86IGJvb2xlYW47XG4gIEBJbnB1dCgpIHByaXZhdGUgdHJhbnNmb3JtPzogc3RyaW5nIHwgVHJhbnNmb3JtO1xuXG4gIC8qKlxuICAgKiBVcGRhdGluZyBwYXJhbXMgYnkgY29tcG9uZW50IHByb3BzLlxuICAgKi9cbiAgcHJvdGVjdGVkIHVwZGF0ZVBhcmFtcygpIHtcbiAgICBjb25zdCBjbGFzc09wdHM6IEZhUHJvcHMgPSB7XG4gICAgICBmbGlwOiB0aGlzLmZsaXAsXG4gICAgICBzcGluOiB0aGlzLnNwaW4sXG4gICAgICBwdWxzZTogdGhpcy5wdWxzZSxcbiAgICAgIGJvcmRlcjogdGhpcy5ib3JkZXIsXG4gICAgICBpbnZlcnNlOiB0aGlzLmludmVyc2UsXG4gICAgICBsaXN0SXRlbTogdGhpcy5saXN0SXRlbSxcbiAgICAgIHNpemU6IHRoaXMuc2l6ZSB8fCBudWxsLFxuICAgICAgcHVsbDogdGhpcy5wdWxsIHx8IG51bGwsXG4gICAgICByb3RhdGU6IHRoaXMucm90YXRlIHx8IG51bGwsXG4gICAgICBmaXhlZFdpZHRoOiB0aGlzLmZpeGVkV2lkdGhcbiAgICB9O1xuXG4gICAgY29uc3QgY2xhc3NlcyA9IG9iamVjdFdpdGhLZXkoJ2NsYXNzZXMnLCBbLi4uZmFDbGFzc0xpc3QoY2xhc3NPcHRzKSwgLi4udGhpcy5jbGFzc2VzXSk7XG4gICAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gdHlwZW9mIHRoaXMudHJhbnNmb3JtID09PSAnc3RyaW5nJyA/IHBhcnNlLnRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSkgOiB0aGlzLnRyYW5zZm9ybTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBvYmplY3RXaXRoS2V5KCd0cmFuc2Zvcm0nLCBwYXJzZWRUcmFuc2Zvcm0pO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB7XG4gICAgICAuLi50cmFuc2Zvcm0sXG4gICAgICAuLi5jbGFzc2VzLFxuICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzXG4gICAgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZW5kZXJGb250YXdlc29tZU9iamVjdChjb250ZW50OiBzdHJpbmcsIHBhcmFtcz86IFRleHRQYXJhbXMpIHtcbiAgICByZXR1cm4gdGV4dChjb250ZW50LCBwYXJhbXMpO1xuICB9XG59XG5cbiIsImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgSG9zdEJpbmRpbmdcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBjb3VudGVyLFxuICBDb3VudGVyLFxuICBDb3VudGVyUGFyYW1zLFxufSBmcm9tICdAZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtc3ZnLWNvcmUnO1xuaW1wb3J0IHsgRmFMYXllcnNUZXh0QmFzZUNvbXBvbmVudCB9IGZyb20gJy4vbGF5ZXJzLXRleHQtYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIEZvbnRhd2Vzb21lIGxheWVycyBjb3VudGVyLlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdmYS1sYXllcnMtY291bnRlcicsXG4gIHRlbXBsYXRlOiAnJyxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnbmctZmEtbGF5ZXJzLWNvdW50ZXInXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgRmFMYXllcnNDb3VudGVyQ29tcG9uZW50IGV4dGVuZHMgRmFMYXllcnNUZXh0QmFzZUNvbXBvbmVudCB7XG5cbiAgLyoqXG4gICAqIFVwZGF0aW5nIHBhcmFtcyBieSBjb21wb25lbnQgcHJvcHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgdXBkYXRlUGFyYW1zKCkge1xuICAgIHRoaXMucGFyYW1zID0ge1xuICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzLFxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyRm9udGF3ZXNvbWVPYmplY3QoY29udGVudDogc3RyaW5nIHwgbnVtYmVyLCBwYXJhbXM/OiBDb3VudGVyUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvdW50ZXIoY29udGVudCwgcGFyYW1zKTtcbiAgfVxufVxuXG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgRmFJY29uQ29tcG9uZW50IH0gZnJvbSAnLi9pY29uL2ljb24uY29tcG9uZW50JztcbmltcG9ydCB7IEZhTGF5ZXJzQ29tcG9uZW50IH0gZnJvbSAnLi9sYXllcnMvbGF5ZXJzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYUxheWVyc1RleHRDb21wb25lbnQgfSBmcm9tICcuL2xheWVycy9sYXllcnMtdGV4dC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFMYXllcnNDb3VudGVyQ29tcG9uZW50IH0gZnJvbSAnLi9sYXllcnMvbGF5ZXJzLWNvdW50ZXIuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW1xuICAgIEZhSWNvbkNvbXBvbmVudCxcbiAgICBGYUxheWVyc0NvbXBvbmVudCxcbiAgICBGYUxheWVyc1RleHRDb21wb25lbnQsXG4gICAgRmFMYXllcnNDb3VudGVyQ29tcG9uZW50XG4gIF0sXG4gIGV4cG9ydHM6IFtcbiAgICBGYUljb25Db21wb25lbnQsXG4gICAgRmFMYXllcnNDb21wb25lbnQsXG4gICAgRmFMYXllcnNUZXh0Q29tcG9uZW50LFxuICAgIEZhTGF5ZXJzQ291bnRlckNvbXBvbmVudFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBGb250QXdlc29tZU1vZHVsZSB7XG59XG4iXSwibmFtZXMiOlsidHNsaWJfMS5fX2V4dGVuZHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBTUEsQUFBTyxxQkFBTSxZQUFZLEdBQUcsVUFBQyxDQUFXO0lBQ3RDLE9BQU8sbUJBQWEsQ0FBQyxHQUFFLE1BQU0sS0FBSyxTQUFTLElBQUksbUJBQWEsQ0FBQyxHQUFFLFFBQVEsS0FBSyxTQUFTLENBQUM7Q0FDdkYsQ0FBQzs7Ozs7O0FDTkY7Ozs7QUFNQSxBQUFPLHFCQUFNLG1CQUFtQixHQUFHLFVBQUMsUUFBa0I7SUFDcEQscUJBQU0sYUFBYSxHQUFHLEtBQUssQ0FBQztJQUU1QixJQUFJLE9BQU8sUUFBUSxLQUFLLFdBQVcsSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFO1FBQ3hELE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxJQUFJLFlBQVksQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUMxQixPQUFPLFFBQVEsQ0FBQztLQUNqQjtJQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxtQkFBZ0IsUUFBUSxHQUFFLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDckUsT0FBTyxFQUFFLE1BQU0sRUFBRSxRQUFRLENB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